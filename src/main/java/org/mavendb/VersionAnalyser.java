package org.mavendb;

import java.util.StringTokenizer;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * Version string analysis result.
 */
public final class VersionAnalyser {

    private static final long MAJOR_VERSION_MAX = 922;
    private static final long MAJOR_VERSION_MAX_YEAR = 9223372036L;
    private static final int RADIX_DECIMAL = 10;
    /**
     * Length of a year string. Example: in <code>2000.01.01</code>, so
     * year's length is 4.
     */
    private static final int YEAR_LENGTH = 10;

    private static final String DOT = ".";
    private static final String DOTS = "..";

    /**
     * The major version of the artifact. We don't expect the major version
     * is too big, usually it is 1, 2, 3, etc.
     */
    private final int majorVersionResult;
    private final long versionSeqResult;

    /**
     * Get maven version sequence. The value is generated by the following
     * logic:
     *
     * <pre>
     *   9,22 3,372,036,854,775,807
     *  |- --|- ---|--- ---|--- ---|
     *   Maj  Min  Incre   4th
     *
     * The left 4 digits are Major Version;
     * then 3 digits are Minor Version;
     * then 6 digits are Incremental Version;
     * then the last 4 digits are the fourth Version.
     * </pre>
     *
     * Well in case we suspect the version is a date format, it will be:
     *
     * <pre>
     *   9,223,372,036,854,775,807
     *   - --- --- ---|--- ---|---|
     *            Year   Month Date
     * Example version text
     * - com.hack23.cia           | citizen-intelligence-agency | 2016.12.13
     * - org.everit.osgi.dev.dist | eosgi-dist-felix_5.2.0      | v201604220928
     * - berkano                  | berkano-sample              | 20050805.042414
     * </pre>
     *
     * @param version Version string
     */
    @SuppressWarnings({"checkstyle:MagicNumber", "java:S3776"}) // java:S3776 - Cognitive Complexity of methods should not be too high
    public VersionAnalyser(final String version) {
        if (version == null) {
            this.majorVersionResult = 0;
            this.versionSeqResult = 0;
            return;
        }

        String majorVersionStr = "";
        long majorVersion = 0;
        long minorVersion = 0;
        long increVersion = 0;
        long four4Version = 0;

        String versionTemp = version.replaceAll("[^\\d.]", DOT);
        if (versionTemp.contains(DOT)) {
            while (versionTemp.contains(DOTS)) {
                versionTemp = versionTemp.replace(DOTS, DOT);
            }
            StringTokenizer tokenizer = new StringTokenizer(versionTemp, DOT);

            if (tokenizer.hasMoreTokens()) {
                majorVersionStr = tokenizer.nextToken();
                majorVersion = NumberUtils.toLong(majorVersionStr);
                majorVersion = (majorVersion > VersionAnalyser.MAJOR_VERSION_MAX) ? VersionAnalyser.MAJOR_VERSION_MAX : majorVersion;
            }
            if (tokenizer.hasMoreTokens()) {
                minorVersion = NumberUtils.toLong(tokenizer.nextToken());
            }
            if (tokenizer.hasMoreTokens()) {
                increVersion = NumberUtils.toLong(tokenizer.nextToken());
            }
            if (tokenizer.hasMoreTokens()) {
                four4Version = NumberUtils.toLong(tokenizer.nextToken());
            }
        } else {
            four4Version = NumberUtils.toLong(versionTemp);
        }

        long seq;
        if (majorVersion == VersionAnalyser.MAJOR_VERSION_MAX) {
            // We suspect the version string is usually a year.month.date
            // So we set major version as the year
            String upTo4char = majorVersionStr.substring(0, Math.min(majorVersionStr.length(), YEAR_LENGTH));
            majorVersion = NumberUtils.toLong(upTo4char);
            seq = shrinkLong(NumberUtils.toLong(majorVersionStr),
                    MAJOR_VERSION_MAX_YEAR) * 1000000000L + shrinkLong(minorVersion, 999999) * 1000L + shrinkLong(increVersion, 999);
        } else {
            // All other cases
            seq = majorVersion * 10000000000000000L
                    + shrinkLong(minorVersion, 9999) * 1000000000000L
                    + shrinkLong(increVersion, 999999) * 1000000L
                    + shrinkLong(four4Version, 999999);
        }

        // Set results
        this.majorVersionResult = (majorVersion >= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) majorVersion;
        this.versionSeqResult = seq;
    }

    /**
     * Return {@link #majorVersionResult} value.
     *
     * @return Value of {@link #majorVersionResult}
     */
    public int getMajorVersion() {
        return this.majorVersionResult;
    }

    /**
     * Return {@link #versionSeqResult} value.
     *
     * @return Value of {@link #versionSeqResult}
     */
    public long getVersionSeq() {
        return this.versionSeqResult;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
        return this.majorVersionResult + ", " + this.versionSeqResult;
    }

    /**
     * Shrink a long value to avoid it exceed the limit.
     *
     * @param value Value to shrink
     * @param limit Max value allowed
     * @return Value no more than the limit
     */
    private long shrinkLong(final long value, final long limit) {
        long temp = value;
        while (temp > limit) {
            temp = temp / RADIX_DECIMAL;
        }

        return temp;
    }
}
